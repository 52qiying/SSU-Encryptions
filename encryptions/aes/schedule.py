import aes

rcon = [
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb
]


# returns a copy of the word shifted n bytes (chars)
# positive values for n shift bytes left, negative values shift right
def rotate(word, n):
    return word[n:] + word[0:n]


# iterate over each "virtual" row in the state table and shift the bytes
# to the LEFT by the appropriate offset
def shift_rows(state):
    for i in range(4):
        state[i * 4:i * 4 + 4] = rotate(state[i * 4:i * 4 + 4], i)


# iterate over each "virtual" row in the state table and shift the bytes
# to the RIGHT by the appropriate offset
def shift_rows_inv(state):
    for i in range(4):
        state[i * 4:i * 4 + 4] = rotate(state[i * 4:i * 4 + 4], -i)


# takes 4-byte word and iteration number
def key_schedule_core(word, i):
    # rotate word 1 byte to the left
    word = rotate(word, 1)
    new_word = []
    # apply sbox substitution on all bytes of word
    for byte in word:
        new_word.append(aes.sbox[byte])
    # XOR the output of the rcon[i] transformation with the first part of the word
    new_word[0] = new_word[0] ^ rcon[i]
    return new_word


# expand 256 bit cipher key into 240 byte key from which
# each round key is derived
def expand_key(key_cipher):
    key_cipher_size = len(key_cipher)
    assert key_cipher_size == 32
    # container for expanded key
    key_expanded = []
    size_current = 0
    iter_rcon = 1
    # temporary list to store 4 bytes at a time
    t = [0, 0, 0, 0]

    # copy the first 32 bytes of the cipher key to the expanded key
    for i in range(key_cipher_size):
        key_expanded.append(key_cipher[i])
    size_current += key_cipher_size

    # generate the remaining bytes until we get a total key size
    # of 240 bytes
    while size_current < 176:
        # assign previous 4 bytes to the temporary storage t
        for i in range(4):
            t[i] = key_expanded[(size_current - 4) + i]

        # every 32 bytes apply the core schedule to t
        if size_current % key_cipher_size == 0:
            t = key_schedule_core(t, iter_rcon)
            iter_rcon += 1

        # XOR t with the 4-byte block [16,24,32] bytes before the end of the
        # current expanded key. These 4 bytes become the next bytes in the
        # expanded key
        for i in range(4):
            key_expanded.append(((key_expanded[size_current - key_cipher_size]) ^ (t[i])))
            size_current += 1

    return key_expanded


def create_round_key(key_expanded, n):
    return key_expanded[(n * 16):(n * 16 + 16)]
